# 1장 오브젝트와 의존관계

***

스프링은 자바를 기반으로 한 기술이다.   
스프링을 이해하려면 먼저 오브젝트에 깊은 관심을 가져야 한다.
***

## 1.1 초난감 DAO

DAO
> Data Access Object : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 object.



### JDBC를 이용하는 작업의 일반적인 순서
1. DB 연결을 위한 connection 불러온다.
2. SQL을 담은 Statement 를 만든다.
3. 만들어진 statement 실행.
4. 조회의 경우 SQL 쿼리의 실행결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
5. 작업 중에 생성된 connection, statement, ResultSet 같은 리소스 작업을 마친 후 반드시 닫아준다.
6. JDBC API 가 만들어내는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하는 메소드 밖으로 던지게 한다.

***

## 1.2 DAO의 분리

***

### 관심사의 분리

- 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.
- 미래를 위해 설계하고 개발해야 한다.
- 객체지향 설게와 프로그래밍이 이전의 절차적 프로그래밍 패러다임에 비해 초기에 좀 더 많은, 번거러운 작업을 요구 -> 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적인 특징.

### "분리"와 "확장"을 고려한 설계를 해야한다!!


## 분리

- 모든 변경과 발전은 한 번에 **한 가지 관심사항** 에 집중해서 일어난다.
- 문제는, 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다.

### " 관심사의 분리 Separation of Concerns"


> 예시) DB 커넥션 분리-상속을 통한 분리
>   >  ``` java 
>   > public abstract class UserDao {
>   > 
>   >   public void add(User user) throws ClassNotFoundException, SQLException {>   > 
>   >       Connection c = getConnection();
>   >       ...
>   >   }
>   > 
>   >   public User get(String id) throws ClassNotFoundException, SQLException {
>   >       Connection C = getConnection(); 
>   >       ...
>   >   }
>   > 
>   >   public abstact Connection getConnection() throws ClassNotFoundException, SQLException;
>   >   
>   > }
>   > 
>   > ```
>   >
>   > ``` java
>   > public class NUserDao extends UserDao {
>   > 
>   >   public Connection getConnection() throws ClassNotFoundException, SQLException {
>   >       //N사 DB connection 생성코드
>   >   }
>   > 
>   > public class DUserDao extends UserDao {
>   > 
>   >   public Connection getConnection() throws ClassNotFoundException, SQLException {
>   >       // D 사 DB connection 생성코드
>   >   }
>   > }




- **템플릿 메소드 패턴 (template method pattern )**
> 이렇게 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을


- **팩토리 메소드 패턴 (Factory Method Pattern)**

> UserDao 의 서브클래스의 getConnection 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정한다. 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 방법


***

## 1.3 DAO확장
- 모든 오브젝트는 변화의 이유와 시기, 주기 등이 다르다.
***
### 1.3.1 클래스의 분리

- 상속관계도 아닌 완전히 독립적인 클래스

> ``` java
> public abstract class UserDao {
>    private SimpleConnectionMaker simpleConnectionMaker;
>
>    public void add(User user) throws ClassNotFoundException, SQLException {
> 
>      ...
>    }
>
>    public User get(String id) throws ClassNotFoundException, SQLException {
>
>        Connection c = simpleConnectionMaker.makeNewConnection();
>
>       ...
>
>    }
> }
>

> 독립시킨 DB 연결 기능 SimpleConnectionMaker
> ``` java
> public class SimpleConnectionMaker {
>   public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
>       Class.forName("org.mariadb.jdbc.Driver");
>       Connection c = DriverManager
>                .getConnection("jdbc:mysql://127.0.0.1:3306/springbook", "root", "password");
>        return c;
>    }
> }


### 문제점
- 상속처럼 자유로운 확장이 가능하게 하려면 DB 커넥션 메소드의 인터페이스가 동일해야한다.
- 커넥션을 제공하는 클래스의 이름을 구체적으로 알아야한다.



### 1.3.2 인터페이스의 도입

- 두 개의 클래스가 서로 긴밀하게 연결되지 않도록 중간에 추상적인 연결고리 만들어주자! => 추상화

**추상화**
> 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업.

**자바가 추상화를 위해 제공하는 가장 유용한 도구는 **인터페이스** 이다.**

- 인터페이스를 사용하면 인터페이스의 메소드르 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에 관심을 둘 필요 없다.


> ConnectionMaker 인터페이스
> ``` java
>  public interface ConnectionMaker {
>       public Connection makeConnection() throws ClassNotFoundException, SQLException;
>   }
>

> ConnectionMaker 구현체
> ``` java
> public class DConnectionMaker implements ConnecctionMaker {
>   ...
>   public Connection makeConnection() throws ClassNotFoundException, SQLException {
>       // D 사의 Connection 코드
>   }
> }

> ConnectionMaker 인터페이스 사용하도록 구현한 UserDao구현체
> ``` java
> public class UserDao {
>   private ConnectionMaker connectionMaker;
> 
>   public UserDao() {
>       connectionMaker = new DConnectionMaker();
>   }
>   
>   public void add(User user) throws ClassNotFoundException, SQLException {
>       Connection c = connectionMaker.makeConnection();
>      ...
>   }
>
>   public User get(String id) throws ClassNotFoundException, SQLException {
>       Connection c = connectionMaker.makeConnection();
>       ...
>
>    }


### 문제점
> connectionMaker = new DConnectionMaker();
- UserDao 에 DConnection 클래스의 생성자를 호출해서 오브젝트를 생성하는 코드가 남아있다.
- UserDao 와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이에 관계를 설정해주는 것에 관한 관심을 분리하자.

> ``` java
> ...
> public static void main(String[] args) throws ClassNotFoundException, SQLException  {
>  
>  ConnectionMaker connectionMaker = new DConnectionMaker();
> 
>   UserDao dao = new UserDao(connectionMaker);
>   ...
>   
>   }

