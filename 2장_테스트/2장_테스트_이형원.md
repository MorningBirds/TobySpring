#2장 테스트

스프링이 개발자에게 제공하는 가장 중요한 가치 -> 객체지향과 테스트.


***

## 2.1 UserDaoTest 다시보기

### 2.1.1 테스트의 유용성

- 테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.
- 또한, 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다.

### 2.1.2 UserDAOTest 특징

## UnitTest
- 작은 단위의 테스트 : 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다.
- 일반적으로 단위는 작을수록 좋다.

### 단위 테스트를 하는 이유
- 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서이다.

## 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다.
***
## 2.2 UserDaoTest 개선

## JUnit 테스트로 전환
- Junit은 프레임워크이다.
- 프레임워크의 기본 동작원리가 바로 제어의 역전이다. 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다.


### JUnit 프레임워크 요구하는 두가지 조건
1. 메소드가 public 선언
2. @Test 메소드에 붙여주기


***
## 2.3 개발자를 위한 테스팅 프레임워크 JUnit


### 테스트 주도 개발

- 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법.
- 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짧게 권장.

### 테스트 코드 개선

- @Before

> JUnit 테스트 수행 방식
1. 테스트 클래스에서 @Test 가 붙은 public 이고 void형이며 파라미터가 없는 테스트 메서드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before 가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번 반복
7. 모든 테스트의 결과 종합 후 돌려준다.

- 각 테스트 메소드를 실행할 때 마다 테스트 클래스의 오브젝트를 새로 만든다. 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다.
- JUnit은 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다.

### 픽스쳐 : 테스트를 수행하는 데 필요한 정보나 오브젝트.

***

## 2.4 스프링 테스트 적용

- @Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 어플리케이션 컨텍스트도 세번 만들어진다.
- 빈이 많아지고 복잡해지면 어플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다.
- 어플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다.
- 스태틱 필드에 어플리케이션 컨텍스트를 저장해주자!


### 2.4.1 테스트를 위한 어플리케이션 컨텍스트 관리.

> ```java
> @RunWith(SpringJunit$ClassRunner.class)
> @ContextConfiguration(locations= "/applicationContext.xml")
> public class UserDaoTest {
>   @Autowired
>   private ApplicationContext context;
> 
>   ...
> 
> }
>```

- 인스턴스 변수인 context는 어디에서도 초기화해주는 코드가 없다.

- @Runwith은 Junit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션이다.
    - SpringJUnit4ClassRunner 라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 테스트를 진행하는 중에 테스트가 사용할 어플리케이션 컨텍스트를 만들고 관리 해주는 작업을 해준다.
- @ContextConfiguration 은 자동으로 만들어줄 어플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.

### 테스트 메소드의 컨텍스트 공유
- context 는 매번 동일 한 오브젝트 값.
- 첫 번째 테스트가 실행될 떄 최초로 어플리케이션 컨텍스트가 처음 만들어지면서 가장 오랜 시간이 소모되고, 그 다음부터는 이미 만들어진 어플리케이션 컨텍스트를 재사용 하기 떄문에 테스트 시간이 매우 짧아진다.

### 테스트 클래스의 컨텍스트 공유
- 두 개의 테스트 클래스가 같은 설정파일을 사용하는 경우에는 테스트 수행중에 단 한개의 어플리케이션 컨텍스트만 만들어지고 공유한다.

### @Autowired
- 스프링의 DI에 사용되는 특별한 어노테이션.
- @autowired가 붙은 인스턴스 변수가 있으면, 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 주입해준다.
- @Autowired 는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다.
- 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한데


##DI 와 테스트

> " 우리는 절대로 DataSource의 구현 클래스를 바꾸지 않을 것이다. 이럴 때도 굳이 인터페이스를 사용하고 DI를 통해 주입하여야하는가?"
1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.
2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.
3. 테스트 떄문이다. 단지 효율적인 테스트를 손쉽게 만들기 위해서는 DI를 적용해야 한다.


***
